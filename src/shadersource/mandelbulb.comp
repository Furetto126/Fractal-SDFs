#version 460
#extension GL_ARB_gpu_shader_fp64 : require

layout (local_size_x = 8, local_size_y = 4, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D imgOut;

uniform float time;

const float PI = 3.14159;
const float EPSILON = 1e-5;
const int RAY_STEPS = 400;
const float MAX_DIST = 100.0;

float DE_Mandelbulb(vec3 c)
{
    const int ITER = 100;
    const float ESCAPE_RADIUS = 4.0;
    const float EXP = max(8.0 * (0.5 + 0.5*sin(time*0.5)), 2.0);

    vec3 z   = c;
    float dr = 1.0;
    float r  = 0.0;
    for (int i = 0; i < ITER; i++)
    {
        r = length(z);
        if (r > ESCAPE_RADIUS) break;

        float theta = acos(z.z / r);
        float phi   = atan(z.y,z.x);
        dr          = pow(r, EXP-1.0)*EXP*dr + 1.0;

        float zr = pow(r, EXP);
        theta   *= EXP;
        phi     *= EXP;

        z = zr * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)) + c;
    }
    return 0.5 * log(r) * r / dr;
}

struct RaymarchInfo {
    bool hit;
    int steps;
    float t;
};

RaymarchInfo raymarch(vec3 start, vec3 dir)
{
    float t = 0.0;
    bool hit = false;
    int i;

    for (i = 0; i < RAY_STEPS; i++)
    {
        vec3 p = start + t*dir;
        float d = DE_Mandelbulb(p);
        if (d < EPSILON) {
            hit = true;
            break;
        }

        t += d;
        if (t > MAX_DIST) break;
    }

    return RaymarchInfo(hit, i, t);
}

void main()
{
    vec2 fragCoord  = vec2(gl_GlobalInvocationID.xy);
    vec2 resolution = vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);

    vec2 uv = fragCoord/resolution;

    vec3 camera = vec3(cos(time), 0.0, sin(time)) * 2.0;
    vec2 ndc = (2.0 * fragCoord - resolution) / resolution.y;
    vec3 target = vec3(0.0);
    vec3 up     = vec3(0.0, 1.0, 0.0);

    vec3 dir = normalize(target - camera);
    vec3 right  = normalize(cross(dir, up));
    vec3 camUp  = cross(right, dir);

    const float FOV = PI*0.5;
    float focalLength = 1.0 / tan(FOV*0.5);
    vec3 rayDir = normalize(ndc.x * right + ndc.y * camUp + focalLength * dir);

    RaymarchInfo info = raymarch(camera, rayDir);
    
    vec3 col = vec3(0.0);
    if (info.hit) {
        col = vec3(float(info.steps) / float(RAY_STEPS));
    }

    imageStore(imgOut, ivec2(fragCoord), vec4(col, 1.0));
}